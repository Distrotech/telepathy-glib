%%
headers
#include <pygobject.h>

#include <gst/gst.h>

#include <telepathy-farstream/telepathy-farstream.h>

#include <telepathy-glib/dbus.h>
#include <telepathy-glib/channel.h>

#include "pygstminiobject.h"

static gboolean
_fs_codec_list_from_pysequence (PyObject *obj, GList **list)
{
  GList *codecs = NULL;
  Py_ssize_t i;

  if (!PySequence_Check (obj))
  {
    PyErr_SetString (PyExc_TypeError,
        "The parameter must be a Sequence of FsCodec");
    return FALSE;
  }

  for (i = 0; i < PySequence_Size (obj); i++)
  {
    PyObject *item = PySequence_GetItem (obj, i);

    if (!pyg_boxed_check (item, FS_TYPE_CODEC))
    {
      PyErr_SetString(PyExc_TypeError,
          "The parameter must be a Sequence of FsCodec");
      return FALSE;
    }
  }

  for (i = 0; i < PySequence_Size (obj); i++)
  {
    PyObject *item = PySequence_GetItem (obj, i);

    codecs = g_list_append (codecs, pyg_boxed_get (item, FsCodec));
  }

  *list = codecs;
  return TRUE;
}

static void
async_result_callback_marshal(GObject *source_object,
               GAsyncResult *result,
               gpointer user_data)
{
   PyObject *callback = user_data;
   PyObject *ret;
   PyGILState_STATE state;

   state = pyg_gil_state_ensure();

   ret = PyObject_CallFunction(callback, "NN",
                pygobject_new(source_object),
                pygobject_new((GObject *)result));

    if (ret == NULL) {
      PyErr_Print();
      PyErr_Clear();
    }

    Py_XDECREF(callback);
    Py_XDECREF(ret);

    pyg_gil_state_release(state);
}
%%
modulename tf
%%
import gobject.GObject as PyGObject_Type
import gst.Message as PyGstMessage_Type
%%
ignore-glob
  *_get_type
%%
headers
%%
override tf_content_set_codec_preferences onearg
static PyObject *
_wrap_tf_content_set_codec_preferences (PyGObject *self, PyObject *arg)
{
  gboolean ret = FALSE;
  GError *error = NULL;
  GList *codecs = NULL;

  if (!_fs_codec_list_from_pysequence (arg, &codecs))
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  ret = tf_content_set_codec_preferences (TF_CONTENT(self->obj), codecs,
      &error);
  Py_END_ALLOW_THREADS

  g_list_free (codecs);

  if (pyg_error_check(&error))
    return NULL;

  return PyBool_FromLong (ret);
}
%%
override tf_channel_new_async kwargs
static PyObject *
_wrap_tf_channel_new_async(PyGObject *self, PyObject *args, PyObject *kwargs)
{
  static char *kwlist[] = { "connection_busname", "connection_path",
    "channel_path", "callback", NULL };

  char *busname, *connection_path, *channel_path;
  TpChannel *proxy = NULL;
  TpConnection *connection = NULL;
  TpDBusDaemon *dbus = NULL;
  GError *error = NULL;
  PyObject *callback;
  PyObject *ret = NULL;

  if (!PyArg_ParseTupleAndKeywords (args, kwargs, "sssO:tf_channel_new_async",
      kwlist, &busname, &connection_path, &channel_path, &callback))
    goto out;

  dbus = tp_dbus_daemon_dup (&error);
  if (dbus == NULL)
    {
      pyg_error_check (&error);
      goto out;
    }

  connection = tp_connection_new (dbus, busname, connection_path, &error);
  if (connection == NULL)
    {
      pyg_error_check (&error);
      goto out;
    }

  proxy = tp_channel_new (connection, channel_path, NULL,
    TP_UNKNOWN_HANDLE_TYPE, 0, &error);

  if (proxy == NULL)
    {
      pyg_error_check (&error);
      goto out;
    }

  ret = Py_None;
  Py_XINCREF (callback);
  tf_channel_new_async (proxy, async_result_callback_marshal, callback);

out:
  if (dbus != NULL)
    g_object_unref (dbus);

  if (connection != NULL)
    g_object_unref (connection);

  if (proxy != NULL)
    g_object_unref (proxy);

  return ret;
}
